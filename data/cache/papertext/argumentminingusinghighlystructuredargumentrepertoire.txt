1. Argument network representation for different Walton schemes. 
 The premises block gathers the different premises types (majors, minors). The critical question’s conclusion block assembles the result of the different critical questions together with the results of the different presumption questions that are to be exposed in a specific scheme. Considering the canonical representation for the schemes, we pose some sentiments about the relational database baselines. In our design, we gather the different scheme information into three basic files (tables): Scheme TBL, Scheme Struct TBL and Data TBL. First, the scheme kind is formulated in Scheme TBL Fig. 2, in which rows act as records of data for different schemes, and columns as features (attributes) of records. The Scheme TBL creates an identification number(ID) for each scheme name (Scheme Name), where this ID plays a role of primary key for the table and foreign key in the others. In addition, any ID attribute will stand for the same function in all files. Scheme Struct TBL assembles the different information associated with different schemes. Such that, Scheme Id stands for the foreign key of Scheme TBL, indicating the scheme concerned. The Content field contains the details of the associated information (premises, conclusion,... etc.). The Type field has four values, P for premises, C for conclusion, CQ for critical question and CC for critical argument conclusion. For instance, the expert opinion scheme[4] can be represented as shown in Scheme Struct TBL of Fig. 2. 
 Fig. 2. The main structure of different schemes. 
 The Data TBL table contains all users’ transactions. This table gathers all users’ analysis for dif- ferent arguments. The table consists of : the Stru Id that serves as foreign key for the Scheme Struct TBL’s ID, and refers to a specific part of the scheme details, the Content attribute contains a por- tion of the analyzed text that fulfills the referred fixed scheme part, the Type attribute, which holds three values only, 1 for the supported node, 0 for rebuttal node, -1 for undetermined value that denotes neither supported nor rebuttal node. Since we consider any argument network as a kind of directed rooted tree, the Child Of attribute points to the parent of each node, whereas the root node has no parents (0 refers to no parent). The level attribute refers to the level of each node in the tree, such that the value 0 indicates the root node. Finally, the argumentation no attribute contains the number of the analyzed argument context. For example, the following context below from Araucaria2 repository database[2, 3, 12] is reana- lyzed based on expert opinion scheme as shown in Fig.3 and Fig.4. ”Eight monthold Kyle Mutch’s tragic death was not an accident and he suffered injuries consistent with a punch or a kick, a court heard yesterday. The baby, whose stepfather denies murder, was examined by pathologist Dr James Grieve shortly after his death. Dr. Grieve told the High Court at For far the youngest was covered in bruises and had suffered a crushed intestine as well as severe internal bleeding. When asked by Advocate Depute Mark Stewart, prosecuting, if the bruises could have been caused by an accident, he said ”No. Not in a child that is not walking, not toddling and has not been in a motor car.” Dr. Grieve said the injuries had happened ”pretty quickly” and would be ”difficult for an infant to cope with”. The lecturer in forensic medicines at Aberdeen University told the jury that the bruises could have been caused by a single blow from a blunt instrument, like a closed hand. Death, not accident, court told, ”Evening Telegraph”, Monday, September 13, 2004, p.11” Regarding to the canonical representation for Waltons schemes presented in Fig.1, the given context could be analyzed as shown in Fig.3 based on expert opinion scheme [1]. Moreover, this analysis will be devolved through transaction records, as shown in Fig.4, to the structured data base (RADB) revealing the different parties of the analysis. 
 2.2 Framework Overview.
 Yun Chi et al. [13] surveyed the current algorithms used for mining frequent subtrees from databases. They focused on two main components of these algorithms, the candidate generation step and the support counting step. They revealed that there is no single best tree mining algorithm. Some algo- rithms offer a better time efficiency, while others require less memory. So every time we manipulate the proposed RADB we will consider the time and memory consuming. 
 {2} http:// araucaria.computing.dundee.ac.uk/.
 Fig. 3. The analysis diagram of the above context based on expert opinion scheme. 
 Fig. 4. The transaction records of the above analysis. 
 We draw a preliminary vision for retrieving and mining the RADB, using a framework with ITS component incorporated. The framework as depicted in Fig.5 consists of three main components: the parser module, the mining classifier agent, and the ITS. The parser module receives a statement S from the intended users such as students or agents. the statement is divided by the parser into tokens, then the number of tokens is reduced. Finally the final crucial set of words { I1, I2,..., In } is sent to the classifier agent. The tokens are reduced if they belong to a look up table containing the set of all unnecessary words like{a, an, the,...,etc }, otherwise it is added to the set of tokens to be sent to the classifier agent. The importance of the parser module lies in reducing the set of tokens which in turn will reduce the number of iterations done by the classifier agent, and improve the complexity of the used mining algorithms. The classifier agent classifies the retrieved contexts depending on the students specification. The agent can classify the retrieved arguments by priority, polarity, scheme name, premises (with/against), and by conclusion. 
 Fig. 5. Framework outline.
 The priority aims to show the retrieved contexts organized by the maximum support number based on the classification mining technique AprioriTid [10, 5]. Polarity classifies the retrieved arguments in to two classes, support class and against class, using the text mining techniques. Scheme name retrieves the desired contexts depending on a specific scheme name deter- mined by the student. Premises (with/against) retrieves arguments by searching only in the different premises, and conclusion retrieves and classifies the arguments by searching only in the different conclusions. The classifier agent receives the set of crucial words { I1,I2, ..., In } from the parser module and the search type from the student, then retrieves and classifies the documents that are relevant to the student’s search statement from the RADB using the multi-term text phrases ap- proach[5] such that T={ T1,T2,...,Tm } is the collection of raw documents, I={ I1,I2,,In } is a set of words appearing in T. T’={ T’1, T’2,..., T’m } is the set of documents, where T’i contains a set of multi-term phrases I’={ I’1, I’2,..., I’n }, I’i= Ij [1,2,..,k-j], and Ii can appear in I’i repeatedly. The importance of this classifier agent lays in manging the different mining techniques in order to: (i) direct the search towards hypotheses that are more relevant to the user’s needs, (ii) add flexibility to the retrieving process to suit the users aims (iii) offer a myriad of arguments at users fingertips. After the classifier agent exposed the pertinent contexts to the student, the student picks up one context among them. The student preference then delegates to the ITS program. The program exposes the corresponding context, and gives the student the ability to analyze the selected argu- ment based on a specific chosen scheme. Finally the program negotiates with the student about the way of analysis through mining techniques to (i) provide constrains that guide the argument analysis process based on scheme structure and pre-existing arguments, (ii) refine the user’s underlying classi- fication, (iii) provide an analysis background to the different users, (iv) deepen the understanding of negotiation, decision making, (v) develop critical and intellectual thinking of students, and improve the analysis ability. 
 2.3 Illustrative Example.
 Suppose the student wants to know anything about Iraq war, so he/she come up with a statement ”the destructive war in Iraq”. First the parser module will divide the statement into tokens {the, destructive, war, in, Iraq}, such that I1=the, I2=destructive, I3=war, I4=in, I5=Iraq, then access to the data base through the ODBC connection to compare each token with the lookup table entities and reduce the number of tokens, after checking the lookup table the tokens will be I1=destructive, I2=war, I3=Iraq. So the output will be the item sets {destructive, war, Iraq}. Now the classifier should find the set of raw documents T= {T1,T2,...,Tn }. Assume the conclusion is the search criteria, so the classifier will use the mining AprioriTid algorithm [10, 5] to make all the possible combination of the item sets and classify the result depending on the support number for each combination. Firstly, the algorithm will calculate the support number for each single token, and select the tokens that have support number greater than minsup, that is a number specified by the student, however in our case we will take the minsup=1 so any token appears at least once will be considered. Since we assume that the student choose to search by conclusion then the support number for each token can be counted by the number of transactions resulted from the following select statements. 
 The output of this step will be the set of ordered pairs L1 = {(destructive, 5), (war, 10), (Iraq, 20)}, where the ordered pair is of the form (the token, the support number), and the set A1={argument 801, argument 509,...} which contains the non repetitive arguments (argument no) that contains these tokens. Secondly, the algorithm consequently builds the super set Ck = apriori gen(Lk−1) for all possible combinations of the tokens. Fig.6. Shows the first iteration for C2=apriori gen(L1). 
 Fig. 6. The super set C2 of the singleton token set L1. 
 Then the support number for each combination is checked through the set A1. Suppose that the support number for the item set ”War Iraq” is 0, which is less than the minsup=1, so this item set is neglected. The output of this iteration will be L2= {(Destructive war, 3), (Destructive Iraq, 5)}, and the set A2={argument 509,...}. Finally, the last iteration of our example will out put the set L3={(Destructive war Iraq, 1)} and the set of arguments A3={ argument 509}. Suppose that A3 had more than one argument no, we add function to the algorithm to check the counter argument of each argument no and order the arguments depending on the possessed counter arguments, such that the argument that contains more cons is the weakest. Therefore, the conclusions corresponding to the retrieved arguments are organized, such that the argument1 is highly relevant to the issue of search rather than argumentn as shown in Fig. 7. When the student pickup one of the classified output conclusions the ITS will access to the database to retrieve the corresponding context and then the context is exposed to the student giving him/her the ability to analyze. Furthermore, the ITS will negotiate with the student partially (step by step hints) or totally (compare the student whole analysis with the original one retrieved from the repository) as discussed in the next section, in order to improve his/her analysis skill. 
 Fig. 7. The argument retrieval output. 
 3 Motivation.
 In this paper, firstly we introduce a novel approach to retrieve the information using mining tech- niques based on RADB, which is a highly structured repertoire gathers the argument dataset, such that all needed information is encoded in an appropriate form. This structure facilitates fast in- teraction, and enjoys general applicability since it does not require a specialized knowledge. The idea is to mine the pre-existing arguments in order to (i) direct the search towards hypotheses that are more relevant to the users needs, even with more than one word in the search statement, (ii) add flexibility to the retrieving process to suit the users aims (iii) offer a myriad of arguments at users fingertips (iv) provide an analysis background to the different users. Secondly, we assemble the different retrieving techniques in a Classifier agent to be merged with an ITS. The agent based in- telligent tutoring system aims to (i) provide constrains to guide the argument analysis process based on scheme structure and pre-existing arguments, (ii) refine the users’ underlying classification, (iii) deepen the understanding of negotiation, decision making, develop critical and intellectual thinking of students, and improve the analysis ability. I. Rahwan presents the ArgDf system [1, 6], through which users can create, manipulate, and query arguments using different argumentation schemes. Comparing ArgDf system to our approach, both of them sustain creating new arguments based on existing argument schemes. The available argument schemes are listed, enabling the user to choose the scheme to which the argument belongs. Details of the selected argumentation scheme are then retrieved from the repository, and the generic form of the argument is displayed to the user to guide the creation of the premises and conclusion. For example, querying the ArgDF repository to extract the name of the schemes can be done through the following RQL query. In addition, the ArgDf system guides the user during the creation process based on the scheme structure only, the user relies on his efforts and his background to analyze the argument. However, in our approach, the user is not only guided by the scheme structure but also by crucial hints devolved through mining techniques. Accordingly, the creation process is restricted by comparing the contrasting reconstruction of the user’s analysis and the pre-existing one. such restriction helps in refining the user’s underlying classification. In the ArgDf system, searching existing arguments is revealed by specifying text in the premises or the conclusion, as well as the type of relationship between them. Then the user can choose to filter arguments based on a specific scheme. Whereas, in our approach, searching the existing arguments is not only done by specifying text in the premises or the conclusion but also by providing different strategies based on different mining techniques (as explained in subsection 2.2). This method guarantees the retrieval of the most convenient hypotheses relevant to the subject of search. 
 4 Conclusions and Future Work.
 In this paper, we present a novel approach of building a highly structured argument repertoire (RADB) that uses different mining techniques to support argument analysis, retrieval, and re-usage. The paper also introduced an educational framework that utilizes the RABD. The proposed structure aims to: (i) summon and provide a myriad of arguments at the user’s fingertips, (ii) retrieve the most relevant results to the subject of search, (iii) support the fast interaction between the different mining techniques and the existing arguments, and (iv) facilitate the interoperability among various agents/humans. Our attempt enjoys certain advantages when compared to others, especially with respect to the search of pre-existing arguments. The results obtained are very promising, where highly relevant and convenient arguments are obtained, especially when the search statement is in this form: ”the destructive war in Iraq”. Future work mainly concerns with the implementation of the rest of the framework components.